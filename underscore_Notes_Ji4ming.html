<!--underscoreNotes_Ji4ming_20200615-->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">

    <title> underscoreNotes_Ji4ming </title>

    <script type="text/javascript" src="resources/underscore.js"></script>

</head>
<body>

    <h3 style = "color: red"> arraylist1 = [1, 2, 3] </h3>
    <p> _.each: (select element) </p>
    <p id = "tryeach"></p>

    <p> _.map: (遍历) </p>
    <p id = "trymap"></p>

    <p> _.reduce: (去头直至不为空) </p>
    <p id = "tryreduce"></p>

    <p> _.reduceRight: (右侧去头直至不为空) </p>
    <p id = "tryreduceright"></p>

    <p> _.find: (找到第一个符合条件的元素) </p>
    <p id = "tryfind"></p>

    <p> _.findWhere: (找到第一个符合的元素的元素) </p>
    <p id = "tryfindWhere"> test </p>

    <script>

        // Collections
        var arraylist1 = [1, 2, 3];     // const value
        var arraylist2 = [ [1, 2, 3], [4, 5, 6] ];
        var arraylist3 = [ {num:1, txt:"abc"}, {num:2, txt:"xyz"} ];

        // each    _.each(list, iteratee, [context])
        var each_arraylist1 = _.each(arraylist1, function() { document.getElementById("tryeach").innerHTML = arraylist1[0]; });

        // map    _.map(list, iteratee, [context])
        var double_arraylist1 = _.map(arraylist1, function(num) { return num * 2; });
        document.getElementById("trymap").innerHTML = double_arraylist1;

        // reduce    _.reduce(list, iteratee, [memo], [context])
        var sum_arraylist1 = _.reduce(arraylist1, function(memo, num){ return memo + num; }, - 1);     // return sum - 1
        document.getElementById("tryreduce").innerHTML = sum_arraylist1;

        // reduceRight foldr    _.reduceRight(list, iteratee, [memo], [context])
        var reverse_arraylist2 = _.reduceRight(arraylist2, function(a, b) { return a.concat(b); }, [100]);     // 100 -> first element
        document.getElementById("tryreduceright").innerHTML = reverse_arraylist2;

        // find    _.find(list, predicate, [context])
        var find_arraylist1 = _.find(arraylist1, function(num) { return 0 === num % 2; });
        document.getElementById("tryfind").innerHTML = find_arraylist1;

        // filter    _.filter(list, predicate, [context])
        var filter_arraylist1 = _.filter(arraylist1, function(num) { return num * 2 < 6; });
        document.getElementById("tryfilter").innerHTML = filter_arraylist1;

        // reject   _.reject(list, predicate, [context])     返回的元素与 filter 相反
        // every    _.every(list, [predicate], [context])    list 中没一个元素都符合则 return true else return false
        // some     _.some(list, [predicate], [context])     some 与 every 相反
        // contains _.contains(list, value, [fromIndex])     验证 value 是否在 list 中
        // invoke   _.invoke(list, methodName, *arguments)   将 method 应用到 list 中
    //     pluck    _.pluck(list, propertyName)              返回 list 中所有的 property * 重点 *
        // max      _.max(list, [iteratee], [context])
        // min      _.min(list, [iteratee], [context])
        // sortBy   _.sortBy(list, iteratee, [context])      对 list 排序
        // groupBy  _.groupBy(list, iteratee, [context])     对 list 分组
        // indexBy  _.indexBy(list, iteratee, [context])     对 list 中 property 的 value 进行排序
        // countBy  _.countBy(list, iteratee, [context])     遍历 list 返回某一个 value 的属性的数量
        /*          _.countBy([1, 2, 3, 4, 5], function(num) {
                        return num % 2 == 0 ? 'even': 'odd';
                     });
                     => {odd: 3, even: 2}   */
        // shuffle  _.shuffle(list)
        // sample   _.sample(list, [n])
        // size     _.size(list)
        // partition_.partition(list, predicate)            1 list -> 2 lists
        // compact  _.compact(list)                         移除 空值
        /*          _.compact([0, 1, false, 2, '', 3]);
                    => [1, 2, 3]    */

        // findwhere    _.findWhere(list, properties)    // test fail
        var findwhere_arraylist3 = _.findWhere(arraylist3, {txt:"abc"});
        document.getElementById("tryfindWhere").innerHTML = findwhere_arraylist3;


        // Array

        // first    _.first(array, [n])
        // last     _.last(array, [n])
        // initial  _.initial(array, [n])
        /*          _.initial([5, 4, 3, 2, 1]);
                        => [5, 4, 3, 2]    */
        // rest     _.rest(array, [index])
        /*          _.rest([5, 4, 3, 2, 1]);
                    => [4, 3, 2, 1]    */
        // flatten  _.flatten(array, [shallow])         元素简化
        /*          _.flatten([1, [2], [3, [[4]]]]);
                    => [1, 2, 3, 4];
                    _.flatten([1, [2], [3, [[4]]]], true);
                    => [1, 2, 3, [[4]]];  */
        // without  _.without(array, *values)           移除所有的 value 项
        /*          _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);
                    => [2, 3, 4]    */
        // union    _.union(*arrays)                    并集
        /*          _.union([1, 2, 3], [101, 2, 1, 10], [2, 1]);
                    => [1, 2, 3, 101, 10]  */
        // intersection_.intersection(*arrays)          交集
        // difference_.difference(array, *others)
        /*          _.difference([1, 2, 3, 4, 5], [5, 2, 10]);
                    => [1, 3, 4]  */
        // uniq     _.uniq(array, [isSorted], [iteratee])
        /*          _.uniq([1, 2, 1, 4, 1, 3]);
                    => [1, 2, 4, 3]  */
        // zip      _.zip(*arrays)
        /*          _.zip(['moe', 'larry', 'curly'], [30, 40, 50], [true, false, false]);
                    => [["moe", 30, true], ["larry", 40, false], ["curly", 50, false]]  */
        // unzip    _.unzip(array)
        // object   _.object(list, [values])    Converts arrays into objects.
        /*          _.object(['moe', 'larry', 'curly'], [30, 40, 50]);
                    => {moe: 30, larry: 40, curly: 50}

                    _.object([['moe', 30], ['larry', 40], ['curly', 50]]);
                    => {moe: 30, larry: 40, curly: 50}      */
        // chunk    _.chunk(array, length)
        /*          var partners = _.chunk(_.shuffle(kindergarten), 2);
                    => [["Tyrone", "Elie"], ["Aidan", "Sam"], ["Katrina", "Billie"], ["Little Timmy"]]   */
        // indexOf  _.indexOf(array, value, [isSorted])   index starts from 0, return - 1 -> not present in the array
        // lastIndexOf_.lastIndexOf(array, value, [fromIndex])
        // sortedIndex_.sortedIndex(array, value, [iteratee], [context])
        /* Uses a binary search to determine the smallest index at which the value should be inserted into the array in
        order to maintain the array's sorted order. If an iteratee function is provided, it will be used to compute the
        sort ranking of each value, including the value you pass. The iteratee may also be the string name of the
        property to sort by (eg. length). This function uses operator < (note).

                    _.sortedIndex([10, 20, 30, 40, 50], 35);
                    => 3

                    var stooges = [{name: 'moe', age: 40}, {name: 'curly', age: 60}];
                    _.sortedIndex(stooges, {name: 'larry', age: 50}, 'age');
                    => 1  */
        // findIndex_.findIndex(array, predicate, [context])
        // findLastIndex_.findLastIndex(array, predicate, [context])
    //     range_.range([start], stop, [step])
        /*
                    _.range(10);
                    => [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
                    _.range(1, 11);
                    => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
                    _.range(0, 30, 5);
                    => [0, 5, 10, 15, 20, 25]
                    _.range(0, -10, -1);
                    => [0, -1, -2, -3, -4, -5, -6, -7, -8, -9]
                    _.range(0);
                    => []
        */


        // Functions

        // bind     _.bind(function, object, *arguments)
        /*
                    var func = function(greeting){ return greeting + ': ' + this.name };
                    func = _.bind(func, {name: 'moe'}, 'hi');
                    func();
                    => 'hi: moe'
                    name 属性被绑定在了 function 中，作为 input 常量
        */
        // bindAll  _.bindAll(object, *methodNames)
        // partial  _.partial(function, *arguments)
        /* Partially apply a function by filling in any number of its arguments, without changing its dynamic this value.
           A close cousin of bind. You may pass _ in your list of arguments to specify an argument that should not be
           pre-filled, but left open to supply at call-time.

                    var subtract = function(a, b) { return b - a; };
                    sub5 = _.partial(subtract, 5);
                    sub5(20);
                    => 15
        */
        // memoize  _.memoize(function, [hashFunction])
        /*
                    缓存以节省内存增加速度 https://www.jianshu.com/p/4756fbe61a63
                    var fibonacci = _.memoize(function(n) {
                        return n < 2 ? n: fibonacci(n - 1) + fibonacci(n - 2);
                    });
        */
        // delay    _.delay(function, wait, *arguments)
        // 类似setTimeout，等待wait毫秒后调用function。如果传递可选的参数arguments 当函数function执行时，arguments 会作为参数传入。
        // defer    _.defer(function, *arguments)       延迟调用function直到当前调用栈清空为止，类似使用延时为0的setTimeout方法。对
        // 于执行开销大的计算和无阻塞UI线程的HTML渲染时候非常有用。 如果传递arguments参数，当函数function执行时，arguments 会作为参数传入。
        // throttle _.throttle(function, wait, [options])
        /*
                    var throttled = _.throttle(updatePosition, 100);
                    $(window).scroll(throttled);
           创建并返回一个像节流阀一样的函数，当重复调用函数的时候，至少每隔 wait毫秒调用一次该函数。对于想控制一些触发频率较高的事件有帮助。默认
           情况下，throttle将在你调用的第一时间尽快执行这个function，并且，如果你在wait周期内调用任意次数的函数，都将尽快的被覆盖。如果你想禁
           用第一次首先执行的话，传递{leading: false}，还有如果你想禁用最后一次执行的话，传递{trailing: false}。
        */
        // debounce _.debounce(function, wait, [immediate])
        /*
                    var lazyLayout = _.debounce(calculateLayout, 300);
                    $(window).resize(lazyLayout);
           返回 function 函数的防反跳版本, 将延迟函数的执行(真正的执行)在函数最后一次调用时刻的 wait 毫秒之后. 对于必须在一些输入（多是一些用
           户操作）停止到达之后执行的行为有帮助。 例如: 渲染一个Markdown格式的评论预览, 当窗口停止改变大小之后重新计算布局, 等等. 传参
           immediate 为 true， debounce会在 wait 时间间隔的开始调用这个函数 。（注：并且在 waite 的时间之内，不会再次调用。）在类似不小心
           点了提交按钮两下而提交了两次的情况下很有用。
        */
        // once     _.once(function)
        // after    _.after(count, function)
        // before   _.before(count, function)
        // wrap     _.wrap(function, wrapper)
        /*
                    var hello = function(name) { return "hello: " + name; };
                    hello = _.wrap(hello, function(func) {
                        return "before, " + func("moe") + ", after";
                    });
                    hello();
                    => 'before, hello: moe, after'
                    将第一个函数 function 封装到函数 wrapper 里面, 并把函数 function 作为第一个参数传给 wrapper. 这样可以让 wrapper
                    在 function 运行之前和之后 执行代码, 调整参数然后附有条件地执行.
        */
        // compose  _.compose(*functions)
        /*
                    var greet    = function(name){ return "hi: " + name; };
                    var exclaim  = function(statement){ return statement.toUpperCase() + "!"; };
                    var welcome = _.compose(greet, exclaim);
                    welcome('moe');
                    => 'hi: MOE!'
          返回函数集 functions 组合后的复合函数, 也就是一个函数执行完之后把返回的结果再作为参数赋给下一个函数来执行. 以此类推. 在数学里, 把函
          数 f(), g(), 和 h() 组合起来可以得到复合函数 f(g(h()))。
        */


        // Object Function
        // keys         _.keys(object)                                 检索object拥有的所有可枚举属性的名称。
        // allKeys      _.allKeys(object)                              检索object拥有的和继承的所有属性的名称。
        /*
                        function Stooge(name) {
                            this.name = name;
                        }
                        Stooge.prototype.silly = true;
                        _.allKeys(new Stooge("Moe"));
                        => ["name", "silly"]
        */
        // values       _.values(object)                               返回object对象所有的属性值。
        // mapObject_   .mapObject(object, iteratee, [context])        它类似于map，但是这用于对象。转换每个属性的值。
        /*
                        _.mapObject({start: 5, end: 12}, function(val, key) {
                            return val + 5;
                        });
                        => {start: 10, end: 17}
        */
        // pairs        _.pairs(object)                                把一个 object 转变为一个[key, value]形式的数组。
        /*
                        _.pairs({one: 1, two: 2, three: 3});
                        => [["one", 1], ["two", 2], ["three", 3]]
        */
        // invert       _.invert(object)
        // 返回一个object副本，使其键（keys）和值（values）对换。对于这个操作，必须确保object里所有的值都是唯一的且可以序列号成字符串.
        /*
                        _.invert({Moe: "Moses", Larry: "Louis", Curly: "Jerome"});
                        => {Moses: "Moe", Louis: "Larry", Jerome: "Curly"};
        */
        // create       _.create(prototype, props)
        //              var moe = _.create(Stooge.prototype, {name: "Moe"});
        // functions    _.functions(object)                            返回一个对象里所有的方法值
        // findKey      _.findKey(object, predicate, [context])
        // extend       _.extend(destination, *sources)
        /*
                        _.extend({name: 'moe'}, {age: 50});
                        => {name: 'moe', age: 50}
                        复制是按顺序的, 所以后面的对象属性会把前面的对象属性覆盖掉(如果有重复).
        */
        // extendOwn    _.extendOwn(destination, *sources)             只复制自己的属性覆盖到目标对象。（注：不包括继承过来的属性）
        // pick         _.pick(object, *keys)
        /*
                        _.pick({name: 'moe', age: 50, userid: 'moe1'}, 'name', 'age');
                        => {name: 'moe', age: 50}
                        只过滤出keys(有效的键组成的数组)参数指定的属性值。或者接受一个判断函数，指定挑选哪个key。
        */
        // omit         _.omit(object, *keys)                          与 pick 相反，返回除 *keys 以外的部分
        // defaults     _.defaults(object, *defaults)
        /*
                        var iceCream = {flavor: "chocolate"};
                        _.defaults(iceCream, {flavor: "vanilla", sprinkles: "lots"});
                        => {flavor: "chocolate", sprinkles: "lots"}
                        用defaults对象填充object 中的undefined属性。 并且返回这个object。一旦这个属性被填充，再使用defaults方法将不会有任何效果。
        */
        // clone        _.clone(object)
        // has          _.has(object, key)
        // property     _.property(path)            返回一个函数，这个函数返回任何传入的对象的key属性
        // propertyOf   _.propertyOf(object)        和_.property相反。需要一个对象，并返回一个函数,这个函数将返回一个提供的属性的值。
        // matcher      _.matcher(attrs)            返回一个断言函数
        // is......     index.html in underscore

        // Utility
        // chain

    </script>

</body>
</html>